// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newProgressReports(db *gorm.DB, opts ...gen.DOOption) progressReports {
	_progressReports := progressReports{}

	_progressReports.progressReportsDo.UseDB(db, opts...)
	_progressReports.progressReportsDo.UseModel(&model.ProgressReports{})

	tableName := _progressReports.progressReportsDo.TableName()
	_progressReports.ALL = field.NewAsterisk(tableName)
	_progressReports.ID = field.NewUint(tableName, "id")
	_progressReports.UserID = field.NewUint(tableName, "user_id")
	_progressReports.ReportType = field.NewString(tableName, "report_type")
	_progressReports.PeriodStart = field.NewTime(tableName, "period_start")
	_progressReports.PeriodEnd = field.NewTime(tableName, "period_end")
	_progressReports.OverallWellbeingScore = field.NewInt(tableName, "overall_wellbeing_score")
	_progressReports.MoodSummary = field.NewField(tableName, "mood_summary")
	_progressReports.JournalInsights = field.NewField(tableName, "journal_insights")
	_progressReports.GoalProgress = field.NewField(tableName, "goal_progress")
	_progressReports.MeditationSummary = field.NewField(tableName, "meditation_summary")
	_progressReports.ConsciousnessProgression = field.NewField(tableName, "consciousness_progression")
	_progressReports.KeyAchievements = field.NewString(tableName, "key_achievements")
	_progressReports.AreasForImprovement = field.NewString(tableName, "areas_for_improvement")
	_progressReports.PersonalizedRecommendations = field.NewString(tableName, "personalized_recommendations")
	_progressReports.ChartData = field.NewField(tableName, "chart_data")
	_progressReports.PdfURL = field.NewString(tableName, "pdf_url")
	_progressReports.IsExported = field.NewBool(tableName, "is_exported")
	_progressReports.ExportedAt = field.NewTime(tableName, "exported_at")
	_progressReports.GeneratedAt = field.NewTime(tableName, "generated_at")

	_progressReports.fillFieldMap()

	return _progressReports
}

type progressReports struct {
	progressReportsDo progressReportsDo

	ALL                         field.Asterisk
	ID                          field.Uint
	UserID                      field.Uint
	ReportType                  field.String
	PeriodStart                 field.Time
	PeriodEnd                   field.Time
	OverallWellbeingScore       field.Int
	MoodSummary                 field.Field
	JournalInsights             field.Field
	GoalProgress                field.Field
	MeditationSummary           field.Field
	ConsciousnessProgression    field.Field
	KeyAchievements             field.String
	AreasForImprovement         field.String
	PersonalizedRecommendations field.String
	ChartData                   field.Field
	PdfURL                      field.String
	IsExported                  field.Bool
	ExportedAt                  field.Time
	GeneratedAt                 field.Time

	fieldMap map[string]field.Expr
}

func (p progressReports) Table(newTableName string) *progressReports {
	p.progressReportsDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p progressReports) As(alias string) *progressReports {
	p.progressReportsDo.DO = *(p.progressReportsDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *progressReports) updateTableName(table string) *progressReports {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewUint(table, "id")
	p.UserID = field.NewUint(table, "user_id")
	p.ReportType = field.NewString(table, "report_type")
	p.PeriodStart = field.NewTime(table, "period_start")
	p.PeriodEnd = field.NewTime(table, "period_end")
	p.OverallWellbeingScore = field.NewInt(table, "overall_wellbeing_score")
	p.MoodSummary = field.NewField(table, "mood_summary")
	p.JournalInsights = field.NewField(table, "journal_insights")
	p.GoalProgress = field.NewField(table, "goal_progress")
	p.MeditationSummary = field.NewField(table, "meditation_summary")
	p.ConsciousnessProgression = field.NewField(table, "consciousness_progression")
	p.KeyAchievements = field.NewString(table, "key_achievements")
	p.AreasForImprovement = field.NewString(table, "areas_for_improvement")
	p.PersonalizedRecommendations = field.NewString(table, "personalized_recommendations")
	p.ChartData = field.NewField(table, "chart_data")
	p.PdfURL = field.NewString(table, "pdf_url")
	p.IsExported = field.NewBool(table, "is_exported")
	p.ExportedAt = field.NewTime(table, "exported_at")
	p.GeneratedAt = field.NewTime(table, "generated_at")

	p.fillFieldMap()

	return p
}

func (p *progressReports) WithContext(ctx context.Context) *progressReportsDo {
	return p.progressReportsDo.WithContext(ctx)
}

func (p progressReports) TableName() string { return p.progressReportsDo.TableName() }

func (p progressReports) Alias() string { return p.progressReportsDo.Alias() }

func (p progressReports) Columns(cols ...field.Expr) gen.Columns {
	return p.progressReportsDo.Columns(cols...)
}

func (p *progressReports) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *progressReports) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 19)
	p.fieldMap["id"] = p.ID
	p.fieldMap["user_id"] = p.UserID
	p.fieldMap["report_type"] = p.ReportType
	p.fieldMap["period_start"] = p.PeriodStart
	p.fieldMap["period_end"] = p.PeriodEnd
	p.fieldMap["overall_wellbeing_score"] = p.OverallWellbeingScore
	p.fieldMap["mood_summary"] = p.MoodSummary
	p.fieldMap["journal_insights"] = p.JournalInsights
	p.fieldMap["goal_progress"] = p.GoalProgress
	p.fieldMap["meditation_summary"] = p.MeditationSummary
	p.fieldMap["consciousness_progression"] = p.ConsciousnessProgression
	p.fieldMap["key_achievements"] = p.KeyAchievements
	p.fieldMap["areas_for_improvement"] = p.AreasForImprovement
	p.fieldMap["personalized_recommendations"] = p.PersonalizedRecommendations
	p.fieldMap["chart_data"] = p.ChartData
	p.fieldMap["pdf_url"] = p.PdfURL
	p.fieldMap["is_exported"] = p.IsExported
	p.fieldMap["exported_at"] = p.ExportedAt
	p.fieldMap["generated_at"] = p.GeneratedAt
}

func (p progressReports) clone(db *gorm.DB) progressReports {
	p.progressReportsDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p progressReports) replaceDB(db *gorm.DB) progressReports {
	p.progressReportsDo.ReplaceDB(db)
	return p
}

type progressReportsDo struct{ gen.DO }

func (p progressReportsDo) Debug() *progressReportsDo {
	return p.withDO(p.DO.Debug())
}

func (p progressReportsDo) WithContext(ctx context.Context) *progressReportsDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p progressReportsDo) ReadDB() *progressReportsDo {
	return p.Clauses(dbresolver.Read)
}

func (p progressReportsDo) WriteDB() *progressReportsDo {
	return p.Clauses(dbresolver.Write)
}

func (p progressReportsDo) Session(config *gorm.Session) *progressReportsDo {
	return p.withDO(p.DO.Session(config))
}

func (p progressReportsDo) Clauses(conds ...clause.Expression) *progressReportsDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p progressReportsDo) Returning(value interface{}, columns ...string) *progressReportsDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p progressReportsDo) Not(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p progressReportsDo) Or(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p progressReportsDo) Select(conds ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p progressReportsDo) Where(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p progressReportsDo) Order(conds ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p progressReportsDo) Distinct(cols ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p progressReportsDo) Omit(cols ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p progressReportsDo) Join(table schema.Tabler, on ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p progressReportsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p progressReportsDo) RightJoin(table schema.Tabler, on ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p progressReportsDo) Group(cols ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p progressReportsDo) Having(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p progressReportsDo) Limit(limit int) *progressReportsDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p progressReportsDo) Offset(offset int) *progressReportsDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p progressReportsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *progressReportsDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p progressReportsDo) Unscoped() *progressReportsDo {
	return p.withDO(p.DO.Unscoped())
}

func (p progressReportsDo) Create(values ...*model.ProgressReports) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p progressReportsDo) CreateInBatches(values []*model.ProgressReports, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p progressReportsDo) Save(values ...*model.ProgressReports) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p progressReportsDo) First() (*model.ProgressReports, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) Take() (*model.ProgressReports, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) Last() (*model.ProgressReports, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) Find() ([]*model.ProgressReports, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProgressReports), err
}

func (p progressReportsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProgressReports, err error) {
	buf := make([]*model.ProgressReports, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p progressReportsDo) FindInBatches(result *[]*model.ProgressReports, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p progressReportsDo) Attrs(attrs ...field.AssignExpr) *progressReportsDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p progressReportsDo) Assign(attrs ...field.AssignExpr) *progressReportsDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p progressReportsDo) Joins(fields ...field.RelationField) *progressReportsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p progressReportsDo) Preload(fields ...field.RelationField) *progressReportsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p progressReportsDo) FirstOrInit() (*model.ProgressReports, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) FirstOrCreate() (*model.ProgressReports, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) FindByPage(offset int, limit int) (result []*model.ProgressReports, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p progressReportsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p progressReportsDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p progressReportsDo) Delete(models ...*model.ProgressReports) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *progressReportsDo) withDO(do gen.Dao) *progressReportsDo {
	p.DO = *do.(*gen.DO)
	return p
}
