// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newUserInsights(db *gorm.DB, opts ...gen.DOOption) userInsights {
	_userInsights := userInsights{}

	_userInsights.userInsightsDo.UseDB(db, opts...)
	_userInsights.userInsightsDo.UseModel(&model.UserInsights{})

	tableName := _userInsights.userInsightsDo.TableName()
	_userInsights.ALL = field.NewAsterisk(tableName)
	_userInsights.ID = field.NewUint(tableName, "id")
	_userInsights.UserID = field.NewUint(tableName, "user_id")
	_userInsights.InsightType = field.NewString(tableName, "insight_type")
	_userInsights.InsightCategory = field.NewString(tableName, "insight_category")
	_userInsights.Title = field.NewString(tableName, "title")
	_userInsights.Description = field.NewString(tableName, "description")
	_userInsights.DataPoints = field.NewField(tableName, "data_points")
	_userInsights.PeriodStart = field.NewTime(tableName, "period_start")
	_userInsights.PeriodEnd = field.NewTime(tableName, "period_end")
	_userInsights.IsRead = field.NewBool(tableName, "is_read")
	_userInsights.ReadAt = field.NewTime(tableName, "read_at")
	_userInsights.IsDismissed = field.NewBool(tableName, "is_dismissed")
	_userInsights.DismissedAt = field.NewTime(tableName, "dismissed_at")
	_userInsights.Priority = field.NewString(tableName, "priority")
	_userInsights.ExpiresAt = field.NewTime(tableName, "expires_at")
	_userInsights.CreatedAt = field.NewTime(tableName, "created_at")
	_userInsights.User = userInsightsBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.Users"),
	}

	_userInsights.fillFieldMap()

	return _userInsights
}

type userInsights struct {
	userInsightsDo userInsightsDo

	ALL             field.Asterisk
	ID              field.Uint
	UserID          field.Uint
	InsightType     field.String
	InsightCategory field.String
	Title           field.String
	Description     field.String
	DataPoints      field.Field
	PeriodStart     field.Time
	PeriodEnd       field.Time
	IsRead          field.Bool
	ReadAt          field.Time
	IsDismissed     field.Bool
	DismissedAt     field.Time
	Priority        field.String
	ExpiresAt       field.Time
	CreatedAt       field.Time
	User            userInsightsBelongsToUser

	fieldMap map[string]field.Expr
}

func (u userInsights) Table(newTableName string) *userInsights {
	u.userInsightsDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userInsights) As(alias string) *userInsights {
	u.userInsightsDo.DO = *(u.userInsightsDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userInsights) updateTableName(table string) *userInsights {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewUint(table, "id")
	u.UserID = field.NewUint(table, "user_id")
	u.InsightType = field.NewString(table, "insight_type")
	u.InsightCategory = field.NewString(table, "insight_category")
	u.Title = field.NewString(table, "title")
	u.Description = field.NewString(table, "description")
	u.DataPoints = field.NewField(table, "data_points")
	u.PeriodStart = field.NewTime(table, "period_start")
	u.PeriodEnd = field.NewTime(table, "period_end")
	u.IsRead = field.NewBool(table, "is_read")
	u.ReadAt = field.NewTime(table, "read_at")
	u.IsDismissed = field.NewBool(table, "is_dismissed")
	u.DismissedAt = field.NewTime(table, "dismissed_at")
	u.Priority = field.NewString(table, "priority")
	u.ExpiresAt = field.NewTime(table, "expires_at")
	u.CreatedAt = field.NewTime(table, "created_at")

	u.fillFieldMap()

	return u
}

func (u *userInsights) WithContext(ctx context.Context) *userInsightsDo {
	return u.userInsightsDo.WithContext(ctx)
}

func (u userInsights) TableName() string { return u.userInsightsDo.TableName() }

func (u userInsights) Alias() string { return u.userInsightsDo.Alias() }

func (u userInsights) Columns(cols ...field.Expr) gen.Columns {
	return u.userInsightsDo.Columns(cols...)
}

func (u *userInsights) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userInsights) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 17)
	u.fieldMap["id"] = u.ID
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["insight_type"] = u.InsightType
	u.fieldMap["insight_category"] = u.InsightCategory
	u.fieldMap["title"] = u.Title
	u.fieldMap["description"] = u.Description
	u.fieldMap["data_points"] = u.DataPoints
	u.fieldMap["period_start"] = u.PeriodStart
	u.fieldMap["period_end"] = u.PeriodEnd
	u.fieldMap["is_read"] = u.IsRead
	u.fieldMap["read_at"] = u.ReadAt
	u.fieldMap["is_dismissed"] = u.IsDismissed
	u.fieldMap["dismissed_at"] = u.DismissedAt
	u.fieldMap["priority"] = u.Priority
	u.fieldMap["expires_at"] = u.ExpiresAt
	u.fieldMap["created_at"] = u.CreatedAt

}

func (u userInsights) clone(db *gorm.DB) userInsights {
	u.userInsightsDo.ReplaceConnPool(db.Statement.ConnPool)
	u.User.db = db.Session(&gorm.Session{Initialized: true})
	u.User.db.Statement.ConnPool = db.Statement.ConnPool
	return u
}

func (u userInsights) replaceDB(db *gorm.DB) userInsights {
	u.userInsightsDo.ReplaceDB(db)
	u.User.db = db.Session(&gorm.Session{})
	return u
}

type userInsightsBelongsToUser struct {
	db *gorm.DB

	field.RelationField
}

func (a userInsightsBelongsToUser) Where(conds ...field.Expr) *userInsightsBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userInsightsBelongsToUser) WithContext(ctx context.Context) *userInsightsBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userInsightsBelongsToUser) Session(session *gorm.Session) *userInsightsBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a userInsightsBelongsToUser) Model(m *model.UserInsights) *userInsightsBelongsToUserTx {
	return &userInsightsBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

func (a userInsightsBelongsToUser) Unscoped() *userInsightsBelongsToUser {
	a.db = a.db.Unscoped()
	return &a
}

type userInsightsBelongsToUserTx struct{ tx *gorm.Association }

func (a userInsightsBelongsToUserTx) Find() (result *model.Users, err error) {
	return result, a.tx.Find(&result)
}

func (a userInsightsBelongsToUserTx) Append(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userInsightsBelongsToUserTx) Replace(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userInsightsBelongsToUserTx) Delete(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userInsightsBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a userInsightsBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

func (a userInsightsBelongsToUserTx) Unscoped() *userInsightsBelongsToUserTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userInsightsDo struct{ gen.DO }

func (u userInsightsDo) Debug() *userInsightsDo {
	return u.withDO(u.DO.Debug())
}

func (u userInsightsDo) WithContext(ctx context.Context) *userInsightsDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userInsightsDo) ReadDB() *userInsightsDo {
	return u.Clauses(dbresolver.Read)
}

func (u userInsightsDo) WriteDB() *userInsightsDo {
	return u.Clauses(dbresolver.Write)
}

func (u userInsightsDo) Session(config *gorm.Session) *userInsightsDo {
	return u.withDO(u.DO.Session(config))
}

func (u userInsightsDo) Clauses(conds ...clause.Expression) *userInsightsDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userInsightsDo) Returning(value interface{}, columns ...string) *userInsightsDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userInsightsDo) Not(conds ...gen.Condition) *userInsightsDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userInsightsDo) Or(conds ...gen.Condition) *userInsightsDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userInsightsDo) Select(conds ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userInsightsDo) Where(conds ...gen.Condition) *userInsightsDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userInsightsDo) Order(conds ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userInsightsDo) Distinct(cols ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userInsightsDo) Omit(cols ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userInsightsDo) Join(table schema.Tabler, on ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userInsightsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userInsightsDo) RightJoin(table schema.Tabler, on ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userInsightsDo) Group(cols ...field.Expr) *userInsightsDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userInsightsDo) Having(conds ...gen.Condition) *userInsightsDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userInsightsDo) Limit(limit int) *userInsightsDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userInsightsDo) Offset(offset int) *userInsightsDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userInsightsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *userInsightsDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userInsightsDo) Unscoped() *userInsightsDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userInsightsDo) Create(values ...*model.UserInsights) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userInsightsDo) CreateInBatches(values []*model.UserInsights, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userInsightsDo) Save(values ...*model.UserInsights) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userInsightsDo) First() (*model.UserInsights, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserInsights), nil
	}
}

func (u userInsightsDo) Take() (*model.UserInsights, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserInsights), nil
	}
}

func (u userInsightsDo) Last() (*model.UserInsights, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserInsights), nil
	}
}

func (u userInsightsDo) Find() ([]*model.UserInsights, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserInsights), err
}

func (u userInsightsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserInsights, err error) {
	buf := make([]*model.UserInsights, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userInsightsDo) FindInBatches(result *[]*model.UserInsights, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userInsightsDo) Attrs(attrs ...field.AssignExpr) *userInsightsDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userInsightsDo) Assign(attrs ...field.AssignExpr) *userInsightsDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userInsightsDo) Joins(fields ...field.RelationField) *userInsightsDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userInsightsDo) Preload(fields ...field.RelationField) *userInsightsDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userInsightsDo) FirstOrInit() (*model.UserInsights, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserInsights), nil
	}
}

func (u userInsightsDo) FirstOrCreate() (*model.UserInsights, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserInsights), nil
	}
}

func (u userInsightsDo) FindByPage(offset int, limit int) (result []*model.UserInsights, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userInsightsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userInsightsDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userInsightsDo) Delete(models ...*model.UserInsights) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userInsightsDo) withDO(do gen.Dao) *userInsightsDo {
	u.DO = *do.(*gen.DO)
	return u
}
