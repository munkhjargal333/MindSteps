// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newUserEmotionWheel(db *gorm.DB, opts ...gen.DOOption) userEmotionWheel {
	_userEmotionWheel := userEmotionWheel{}

	_userEmotionWheel.userEmotionWheelDo.UseDB(db, opts...)
	_userEmotionWheel.userEmotionWheelDo.UseModel(&model.UserEmotionWheel{})

	tableName := _userEmotionWheel.userEmotionWheelDo.TableName()
	_userEmotionWheel.ALL = field.NewAsterisk(tableName)
	_userEmotionWheel.ID = field.NewUint(tableName, "id")
	_userEmotionWheel.UserID = field.NewUint(tableName, "user_id")
	_userEmotionWheel.MoodEntryID = field.NewUint(tableName, "mood_entry_id")
	_userEmotionWheel.JournalID = field.NewUint(tableName, "journal_id")
	_userEmotionWheel.PlutchikEmotionID = field.NewInt(tableName, "plutchik_emotion_id")
	_userEmotionWheel.Intensity = field.NewInt(tableName, "intensity")
	_userEmotionWheel.DetectedCombinationID = field.NewInt(tableName, "detected_combination_id")
	_userEmotionWheel.IsAiDetected = field.NewBool(tableName, "is_ai_detected")
	_userEmotionWheel.RecordedAt = field.NewTime(tableName, "recorded_at")
	_userEmotionWheel.User = userEmotionWheelBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.Users"),
	}

	_userEmotionWheel.MoodEntry = userEmotionWheelBelongsToMoodEntry{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("MoodEntry", "model.MoodEntries"),
		User: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("MoodEntry.User", "model.Users"),
		},
		CoreValues: struct {
			field.RelationField
			User struct {
				field.RelationField
			}
			MaslowLevel struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("MoodEntry.CoreValues", "model.CoreValues"),
			User: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("MoodEntry.CoreValues.User", "model.Users"),
			},
			MaslowLevel: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("MoodEntry.CoreValues.MaslowLevel", "model.MaslowLevels"),
			},
		},
		MoodUnit: struct {
			field.RelationField
			MoodCategories struct {
				field.RelationField
			}
			PlutchikEmotions struct {
				field.RelationField
			}
			PlutchikCombinations struct {
				field.RelationField
				Emotion1 struct {
					field.RelationField
				}
				Emotion2 struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("MoodEntry.MoodUnit", "model.MoodUnit"),
			MoodCategories: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("MoodEntry.MoodUnit.MoodCategories", "model.MoodCategories"),
			},
			PlutchikEmotions: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("MoodEntry.MoodUnit.PlutchikEmotions", "model.PlutchikEmotions"),
			},
			PlutchikCombinations: struct {
				field.RelationField
				Emotion1 struct {
					field.RelationField
				}
				Emotion2 struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("MoodEntry.MoodUnit.PlutchikCombinations", "model.PlutchikCombinations"),
				Emotion1: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("MoodEntry.MoodUnit.PlutchikCombinations.Emotion1", "model.PlutchikEmotions"),
				},
				Emotion2: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("MoodEntry.MoodUnit.PlutchikCombinations.Emotion2", "model.PlutchikEmotions"),
				},
			},
		},
	}

	_userEmotionWheel.Journal = userEmotionWheelBelongsToJournal{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Journal", "model.Journals"),
		User: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Journal.User", "model.Users"),
		},
	}

	_userEmotionWheel.PlutchikEmotion = userEmotionWheelBelongsToPlutchikEmotion{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("PlutchikEmotion", "model.PlutchikEmotions"),
	}

	_userEmotionWheel.DetectedCombination = userEmotionWheelBelongsToDetectedCombination{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("DetectedCombination", "model.PlutchikCombinations"),
		Emotion1: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("DetectedCombination.Emotion1", "model.PlutchikEmotions"),
		},
		Emotion2: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("DetectedCombination.Emotion2", "model.PlutchikEmotions"),
		},
	}

	_userEmotionWheel.fillFieldMap()

	return _userEmotionWheel
}

type userEmotionWheel struct {
	userEmotionWheelDo userEmotionWheelDo

	ALL                   field.Asterisk
	ID                    field.Uint
	UserID                field.Uint
	MoodEntryID           field.Uint
	JournalID             field.Uint
	PlutchikEmotionID     field.Int
	Intensity             field.Int
	DetectedCombinationID field.Int
	IsAiDetected          field.Bool
	RecordedAt            field.Time
	User                  userEmotionWheelBelongsToUser

	MoodEntry userEmotionWheelBelongsToMoodEntry

	Journal userEmotionWheelBelongsToJournal

	PlutchikEmotion userEmotionWheelBelongsToPlutchikEmotion

	DetectedCombination userEmotionWheelBelongsToDetectedCombination

	fieldMap map[string]field.Expr
}

func (u userEmotionWheel) Table(newTableName string) *userEmotionWheel {
	u.userEmotionWheelDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userEmotionWheel) As(alias string) *userEmotionWheel {
	u.userEmotionWheelDo.DO = *(u.userEmotionWheelDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userEmotionWheel) updateTableName(table string) *userEmotionWheel {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewUint(table, "id")
	u.UserID = field.NewUint(table, "user_id")
	u.MoodEntryID = field.NewUint(table, "mood_entry_id")
	u.JournalID = field.NewUint(table, "journal_id")
	u.PlutchikEmotionID = field.NewInt(table, "plutchik_emotion_id")
	u.Intensity = field.NewInt(table, "intensity")
	u.DetectedCombinationID = field.NewInt(table, "detected_combination_id")
	u.IsAiDetected = field.NewBool(table, "is_ai_detected")
	u.RecordedAt = field.NewTime(table, "recorded_at")

	u.fillFieldMap()

	return u
}

func (u *userEmotionWheel) WithContext(ctx context.Context) *userEmotionWheelDo {
	return u.userEmotionWheelDo.WithContext(ctx)
}

func (u userEmotionWheel) TableName() string { return u.userEmotionWheelDo.TableName() }

func (u userEmotionWheel) Alias() string { return u.userEmotionWheelDo.Alias() }

func (u userEmotionWheel) Columns(cols ...field.Expr) gen.Columns {
	return u.userEmotionWheelDo.Columns(cols...)
}

func (u *userEmotionWheel) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userEmotionWheel) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 14)
	u.fieldMap["id"] = u.ID
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["mood_entry_id"] = u.MoodEntryID
	u.fieldMap["journal_id"] = u.JournalID
	u.fieldMap["plutchik_emotion_id"] = u.PlutchikEmotionID
	u.fieldMap["intensity"] = u.Intensity
	u.fieldMap["detected_combination_id"] = u.DetectedCombinationID
	u.fieldMap["is_ai_detected"] = u.IsAiDetected
	u.fieldMap["recorded_at"] = u.RecordedAt

}

func (u userEmotionWheel) clone(db *gorm.DB) userEmotionWheel {
	u.userEmotionWheelDo.ReplaceConnPool(db.Statement.ConnPool)
	u.User.db = db.Session(&gorm.Session{Initialized: true})
	u.User.db.Statement.ConnPool = db.Statement.ConnPool
	u.MoodEntry.db = db.Session(&gorm.Session{Initialized: true})
	u.MoodEntry.db.Statement.ConnPool = db.Statement.ConnPool
	u.Journal.db = db.Session(&gorm.Session{Initialized: true})
	u.Journal.db.Statement.ConnPool = db.Statement.ConnPool
	u.PlutchikEmotion.db = db.Session(&gorm.Session{Initialized: true})
	u.PlutchikEmotion.db.Statement.ConnPool = db.Statement.ConnPool
	u.DetectedCombination.db = db.Session(&gorm.Session{Initialized: true})
	u.DetectedCombination.db.Statement.ConnPool = db.Statement.ConnPool
	return u
}

func (u userEmotionWheel) replaceDB(db *gorm.DB) userEmotionWheel {
	u.userEmotionWheelDo.ReplaceDB(db)
	u.User.db = db.Session(&gorm.Session{})
	u.MoodEntry.db = db.Session(&gorm.Session{})
	u.Journal.db = db.Session(&gorm.Session{})
	u.PlutchikEmotion.db = db.Session(&gorm.Session{})
	u.DetectedCombination.db = db.Session(&gorm.Session{})
	return u
}

type userEmotionWheelBelongsToUser struct {
	db *gorm.DB

	field.RelationField
}

func (a userEmotionWheelBelongsToUser) Where(conds ...field.Expr) *userEmotionWheelBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userEmotionWheelBelongsToUser) WithContext(ctx context.Context) *userEmotionWheelBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userEmotionWheelBelongsToUser) Session(session *gorm.Session) *userEmotionWheelBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a userEmotionWheelBelongsToUser) Model(m *model.UserEmotionWheel) *userEmotionWheelBelongsToUserTx {
	return &userEmotionWheelBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

func (a userEmotionWheelBelongsToUser) Unscoped() *userEmotionWheelBelongsToUser {
	a.db = a.db.Unscoped()
	return &a
}

type userEmotionWheelBelongsToUserTx struct{ tx *gorm.Association }

func (a userEmotionWheelBelongsToUserTx) Find() (result *model.Users, err error) {
	return result, a.tx.Find(&result)
}

func (a userEmotionWheelBelongsToUserTx) Append(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userEmotionWheelBelongsToUserTx) Replace(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userEmotionWheelBelongsToUserTx) Delete(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userEmotionWheelBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a userEmotionWheelBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

func (a userEmotionWheelBelongsToUserTx) Unscoped() *userEmotionWheelBelongsToUserTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userEmotionWheelBelongsToMoodEntry struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
	}
	CoreValues struct {
		field.RelationField
		User struct {
			field.RelationField
		}
		MaslowLevel struct {
			field.RelationField
		}
	}
	MoodUnit struct {
		field.RelationField
		MoodCategories struct {
			field.RelationField
		}
		PlutchikEmotions struct {
			field.RelationField
		}
		PlutchikCombinations struct {
			field.RelationField
			Emotion1 struct {
				field.RelationField
			}
			Emotion2 struct {
				field.RelationField
			}
		}
	}
}

func (a userEmotionWheelBelongsToMoodEntry) Where(conds ...field.Expr) *userEmotionWheelBelongsToMoodEntry {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userEmotionWheelBelongsToMoodEntry) WithContext(ctx context.Context) *userEmotionWheelBelongsToMoodEntry {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userEmotionWheelBelongsToMoodEntry) Session(session *gorm.Session) *userEmotionWheelBelongsToMoodEntry {
	a.db = a.db.Session(session)
	return &a
}

func (a userEmotionWheelBelongsToMoodEntry) Model(m *model.UserEmotionWheel) *userEmotionWheelBelongsToMoodEntryTx {
	return &userEmotionWheelBelongsToMoodEntryTx{a.db.Model(m).Association(a.Name())}
}

func (a userEmotionWheelBelongsToMoodEntry) Unscoped() *userEmotionWheelBelongsToMoodEntry {
	a.db = a.db.Unscoped()
	return &a
}

type userEmotionWheelBelongsToMoodEntryTx struct{ tx *gorm.Association }

func (a userEmotionWheelBelongsToMoodEntryTx) Find() (result *model.MoodEntries, err error) {
	return result, a.tx.Find(&result)
}

func (a userEmotionWheelBelongsToMoodEntryTx) Append(values ...*model.MoodEntries) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userEmotionWheelBelongsToMoodEntryTx) Replace(values ...*model.MoodEntries) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userEmotionWheelBelongsToMoodEntryTx) Delete(values ...*model.MoodEntries) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userEmotionWheelBelongsToMoodEntryTx) Clear() error {
	return a.tx.Clear()
}

func (a userEmotionWheelBelongsToMoodEntryTx) Count() int64 {
	return a.tx.Count()
}

func (a userEmotionWheelBelongsToMoodEntryTx) Unscoped() *userEmotionWheelBelongsToMoodEntryTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userEmotionWheelBelongsToJournal struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
	}
}

func (a userEmotionWheelBelongsToJournal) Where(conds ...field.Expr) *userEmotionWheelBelongsToJournal {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userEmotionWheelBelongsToJournal) WithContext(ctx context.Context) *userEmotionWheelBelongsToJournal {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userEmotionWheelBelongsToJournal) Session(session *gorm.Session) *userEmotionWheelBelongsToJournal {
	a.db = a.db.Session(session)
	return &a
}

func (a userEmotionWheelBelongsToJournal) Model(m *model.UserEmotionWheel) *userEmotionWheelBelongsToJournalTx {
	return &userEmotionWheelBelongsToJournalTx{a.db.Model(m).Association(a.Name())}
}

func (a userEmotionWheelBelongsToJournal) Unscoped() *userEmotionWheelBelongsToJournal {
	a.db = a.db.Unscoped()
	return &a
}

type userEmotionWheelBelongsToJournalTx struct{ tx *gorm.Association }

func (a userEmotionWheelBelongsToJournalTx) Find() (result *model.Journals, err error) {
	return result, a.tx.Find(&result)
}

func (a userEmotionWheelBelongsToJournalTx) Append(values ...*model.Journals) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userEmotionWheelBelongsToJournalTx) Replace(values ...*model.Journals) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userEmotionWheelBelongsToJournalTx) Delete(values ...*model.Journals) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userEmotionWheelBelongsToJournalTx) Clear() error {
	return a.tx.Clear()
}

func (a userEmotionWheelBelongsToJournalTx) Count() int64 {
	return a.tx.Count()
}

func (a userEmotionWheelBelongsToJournalTx) Unscoped() *userEmotionWheelBelongsToJournalTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userEmotionWheelBelongsToPlutchikEmotion struct {
	db *gorm.DB

	field.RelationField
}

func (a userEmotionWheelBelongsToPlutchikEmotion) Where(conds ...field.Expr) *userEmotionWheelBelongsToPlutchikEmotion {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userEmotionWheelBelongsToPlutchikEmotion) WithContext(ctx context.Context) *userEmotionWheelBelongsToPlutchikEmotion {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userEmotionWheelBelongsToPlutchikEmotion) Session(session *gorm.Session) *userEmotionWheelBelongsToPlutchikEmotion {
	a.db = a.db.Session(session)
	return &a
}

func (a userEmotionWheelBelongsToPlutchikEmotion) Model(m *model.UserEmotionWheel) *userEmotionWheelBelongsToPlutchikEmotionTx {
	return &userEmotionWheelBelongsToPlutchikEmotionTx{a.db.Model(m).Association(a.Name())}
}

func (a userEmotionWheelBelongsToPlutchikEmotion) Unscoped() *userEmotionWheelBelongsToPlutchikEmotion {
	a.db = a.db.Unscoped()
	return &a
}

type userEmotionWheelBelongsToPlutchikEmotionTx struct{ tx *gorm.Association }

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Find() (result *model.PlutchikEmotions, err error) {
	return result, a.tx.Find(&result)
}

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Append(values ...*model.PlutchikEmotions) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Replace(values ...*model.PlutchikEmotions) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Delete(values ...*model.PlutchikEmotions) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Clear() error {
	return a.tx.Clear()
}

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Count() int64 {
	return a.tx.Count()
}

func (a userEmotionWheelBelongsToPlutchikEmotionTx) Unscoped() *userEmotionWheelBelongsToPlutchikEmotionTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userEmotionWheelBelongsToDetectedCombination struct {
	db *gorm.DB

	field.RelationField

	Emotion1 struct {
		field.RelationField
	}
	Emotion2 struct {
		field.RelationField
	}
}

func (a userEmotionWheelBelongsToDetectedCombination) Where(conds ...field.Expr) *userEmotionWheelBelongsToDetectedCombination {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userEmotionWheelBelongsToDetectedCombination) WithContext(ctx context.Context) *userEmotionWheelBelongsToDetectedCombination {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userEmotionWheelBelongsToDetectedCombination) Session(session *gorm.Session) *userEmotionWheelBelongsToDetectedCombination {
	a.db = a.db.Session(session)
	return &a
}

func (a userEmotionWheelBelongsToDetectedCombination) Model(m *model.UserEmotionWheel) *userEmotionWheelBelongsToDetectedCombinationTx {
	return &userEmotionWheelBelongsToDetectedCombinationTx{a.db.Model(m).Association(a.Name())}
}

func (a userEmotionWheelBelongsToDetectedCombination) Unscoped() *userEmotionWheelBelongsToDetectedCombination {
	a.db = a.db.Unscoped()
	return &a
}

type userEmotionWheelBelongsToDetectedCombinationTx struct{ tx *gorm.Association }

func (a userEmotionWheelBelongsToDetectedCombinationTx) Find() (result *model.PlutchikCombinations, err error) {
	return result, a.tx.Find(&result)
}

func (a userEmotionWheelBelongsToDetectedCombinationTx) Append(values ...*model.PlutchikCombinations) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userEmotionWheelBelongsToDetectedCombinationTx) Replace(values ...*model.PlutchikCombinations) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userEmotionWheelBelongsToDetectedCombinationTx) Delete(values ...*model.PlutchikCombinations) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userEmotionWheelBelongsToDetectedCombinationTx) Clear() error {
	return a.tx.Clear()
}

func (a userEmotionWheelBelongsToDetectedCombinationTx) Count() int64 {
	return a.tx.Count()
}

func (a userEmotionWheelBelongsToDetectedCombinationTx) Unscoped() *userEmotionWheelBelongsToDetectedCombinationTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userEmotionWheelDo struct{ gen.DO }

func (u userEmotionWheelDo) Debug() *userEmotionWheelDo {
	return u.withDO(u.DO.Debug())
}

func (u userEmotionWheelDo) WithContext(ctx context.Context) *userEmotionWheelDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userEmotionWheelDo) ReadDB() *userEmotionWheelDo {
	return u.Clauses(dbresolver.Read)
}

func (u userEmotionWheelDo) WriteDB() *userEmotionWheelDo {
	return u.Clauses(dbresolver.Write)
}

func (u userEmotionWheelDo) Session(config *gorm.Session) *userEmotionWheelDo {
	return u.withDO(u.DO.Session(config))
}

func (u userEmotionWheelDo) Clauses(conds ...clause.Expression) *userEmotionWheelDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userEmotionWheelDo) Returning(value interface{}, columns ...string) *userEmotionWheelDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userEmotionWheelDo) Not(conds ...gen.Condition) *userEmotionWheelDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userEmotionWheelDo) Or(conds ...gen.Condition) *userEmotionWheelDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userEmotionWheelDo) Select(conds ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userEmotionWheelDo) Where(conds ...gen.Condition) *userEmotionWheelDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userEmotionWheelDo) Order(conds ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userEmotionWheelDo) Distinct(cols ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userEmotionWheelDo) Omit(cols ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userEmotionWheelDo) Join(table schema.Tabler, on ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userEmotionWheelDo) LeftJoin(table schema.Tabler, on ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userEmotionWheelDo) RightJoin(table schema.Tabler, on ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userEmotionWheelDo) Group(cols ...field.Expr) *userEmotionWheelDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userEmotionWheelDo) Having(conds ...gen.Condition) *userEmotionWheelDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userEmotionWheelDo) Limit(limit int) *userEmotionWheelDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userEmotionWheelDo) Offset(offset int) *userEmotionWheelDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userEmotionWheelDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *userEmotionWheelDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userEmotionWheelDo) Unscoped() *userEmotionWheelDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userEmotionWheelDo) Create(values ...*model.UserEmotionWheel) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userEmotionWheelDo) CreateInBatches(values []*model.UserEmotionWheel, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userEmotionWheelDo) Save(values ...*model.UserEmotionWheel) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userEmotionWheelDo) First() (*model.UserEmotionWheel, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserEmotionWheel), nil
	}
}

func (u userEmotionWheelDo) Take() (*model.UserEmotionWheel, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserEmotionWheel), nil
	}
}

func (u userEmotionWheelDo) Last() (*model.UserEmotionWheel, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserEmotionWheel), nil
	}
}

func (u userEmotionWheelDo) Find() ([]*model.UserEmotionWheel, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserEmotionWheel), err
}

func (u userEmotionWheelDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserEmotionWheel, err error) {
	buf := make([]*model.UserEmotionWheel, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userEmotionWheelDo) FindInBatches(result *[]*model.UserEmotionWheel, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userEmotionWheelDo) Attrs(attrs ...field.AssignExpr) *userEmotionWheelDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userEmotionWheelDo) Assign(attrs ...field.AssignExpr) *userEmotionWheelDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userEmotionWheelDo) Joins(fields ...field.RelationField) *userEmotionWheelDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userEmotionWheelDo) Preload(fields ...field.RelationField) *userEmotionWheelDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userEmotionWheelDo) FirstOrInit() (*model.UserEmotionWheel, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserEmotionWheel), nil
	}
}

func (u userEmotionWheelDo) FirstOrCreate() (*model.UserEmotionWheel, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserEmotionWheel), nil
	}
}

func (u userEmotionWheelDo) FindByPage(offset int, limit int) (result []*model.UserEmotionWheel, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userEmotionWheelDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userEmotionWheelDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userEmotionWheelDo) Delete(models ...*model.UserEmotionWheel) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userEmotionWheelDo) withDO(do gen.Dao) *userEmotionWheelDo {
	u.DO = *do.(*gen.DO)
	return u
}
