// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newUsers(db *gorm.DB, opts ...gen.DOOption) users {
	_users := users{}

	_users.usersDo.UseDB(db, opts...)
	_users.usersDo.UseModel(&model.Users{})

	tableName := _users.usersDo.TableName()
	_users.ALL = field.NewAsterisk(tableName)
	_users.ID = field.NewUint(tableName, "id")
	_users.UUID = field.NewString(tableName, "uuid")
	_users.Name = field.NewString(tableName, "name")
	_users.Email = field.NewString(tableName, "email")
	_users.Password = field.NewString(tableName, "password")
	_users.TotalScore = field.NewInt(tableName, "total_score")
	_users.CurrentLevel = field.NewInt(tableName, "current_level")
	_users.LevelProgress = field.NewInt(tableName, "level_progress")
	_users.ProfilePicture = field.NewString(tableName, "profile_picture")
	_users.Timezone = field.NewString(tableName, "timezone")
	_users.Language = field.NewString(tableName, "language")
	_users.IsActive = field.NewBool(tableName, "is_active")
	_users.IsEmailVerified = field.NewBool(tableName, "is_email_verified")
	_users.EmailVerifiedAt = field.NewTime(tableName, "email_verified_at")
	_users.LastLogin = field.NewTime(tableName, "last_login")
	_users.LoginCount = field.NewInt(tableName, "login_count")
	_users.CreatedAt = field.NewTime(tableName, "created_at")
	_users.UpdatedAt = field.NewTime(tableName, "updated_at")
	_users.Gamification = usersHasOneGamification{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Gamification", "model.UserGamification"),
		Level: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Gamification.Level", "model.UserLevels"),
		},
	}

	_users.fillFieldMap()

	return _users
}

type users struct {
	usersDo usersDo

	ALL             field.Asterisk
	ID              field.Uint
	UUID            field.String
	Name            field.String
	Email           field.String
	Password        field.String
	TotalScore      field.Int
	CurrentLevel    field.Int
	LevelProgress   field.Int
	ProfilePicture  field.String
	Timezone        field.String
	Language        field.String
	IsActive        field.Bool
	IsEmailVerified field.Bool
	EmailVerifiedAt field.Time
	LastLogin       field.Time
	LoginCount      field.Int
	CreatedAt       field.Time
	UpdatedAt       field.Time
	Gamification    usersHasOneGamification

	fieldMap map[string]field.Expr
}

func (u users) Table(newTableName string) *users {
	u.usersDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u users) As(alias string) *users {
	u.usersDo.DO = *(u.usersDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *users) updateTableName(table string) *users {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewUint(table, "id")
	u.UUID = field.NewString(table, "uuid")
	u.Name = field.NewString(table, "name")
	u.Email = field.NewString(table, "email")
	u.Password = field.NewString(table, "password")
	u.TotalScore = field.NewInt(table, "total_score")
	u.CurrentLevel = field.NewInt(table, "current_level")
	u.LevelProgress = field.NewInt(table, "level_progress")
	u.ProfilePicture = field.NewString(table, "profile_picture")
	u.Timezone = field.NewString(table, "timezone")
	u.Language = field.NewString(table, "language")
	u.IsActive = field.NewBool(table, "is_active")
	u.IsEmailVerified = field.NewBool(table, "is_email_verified")
	u.EmailVerifiedAt = field.NewTime(table, "email_verified_at")
	u.LastLogin = field.NewTime(table, "last_login")
	u.LoginCount = field.NewInt(table, "login_count")
	u.CreatedAt = field.NewTime(table, "created_at")
	u.UpdatedAt = field.NewTime(table, "updated_at")

	u.fillFieldMap()

	return u
}

func (u *users) WithContext(ctx context.Context) *usersDo { return u.usersDo.WithContext(ctx) }

func (u users) TableName() string { return u.usersDo.TableName() }

func (u users) Alias() string { return u.usersDo.Alias() }

func (u users) Columns(cols ...field.Expr) gen.Columns { return u.usersDo.Columns(cols...) }

func (u *users) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *users) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 19)
	u.fieldMap["id"] = u.ID
	u.fieldMap["uuid"] = u.UUID
	u.fieldMap["name"] = u.Name
	u.fieldMap["email"] = u.Email
	u.fieldMap["password"] = u.Password
	u.fieldMap["total_score"] = u.TotalScore
	u.fieldMap["current_level"] = u.CurrentLevel
	u.fieldMap["level_progress"] = u.LevelProgress
	u.fieldMap["profile_picture"] = u.ProfilePicture
	u.fieldMap["timezone"] = u.Timezone
	u.fieldMap["language"] = u.Language
	u.fieldMap["is_active"] = u.IsActive
	u.fieldMap["is_email_verified"] = u.IsEmailVerified
	u.fieldMap["email_verified_at"] = u.EmailVerifiedAt
	u.fieldMap["last_login"] = u.LastLogin
	u.fieldMap["login_count"] = u.LoginCount
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt

}

func (u users) clone(db *gorm.DB) users {
	u.usersDo.ReplaceConnPool(db.Statement.ConnPool)
	u.Gamification.db = db.Session(&gorm.Session{Initialized: true})
	u.Gamification.db.Statement.ConnPool = db.Statement.ConnPool
	return u
}

func (u users) replaceDB(db *gorm.DB) users {
	u.usersDo.ReplaceDB(db)
	u.Gamification.db = db.Session(&gorm.Session{})
	return u
}

type usersHasOneGamification struct {
	db *gorm.DB

	field.RelationField

	Level struct {
		field.RelationField
	}
}

func (a usersHasOneGamification) Where(conds ...field.Expr) *usersHasOneGamification {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a usersHasOneGamification) WithContext(ctx context.Context) *usersHasOneGamification {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a usersHasOneGamification) Session(session *gorm.Session) *usersHasOneGamification {
	a.db = a.db.Session(session)
	return &a
}

func (a usersHasOneGamification) Model(m *model.Users) *usersHasOneGamificationTx {
	return &usersHasOneGamificationTx{a.db.Model(m).Association(a.Name())}
}

func (a usersHasOneGamification) Unscoped() *usersHasOneGamification {
	a.db = a.db.Unscoped()
	return &a
}

type usersHasOneGamificationTx struct{ tx *gorm.Association }

func (a usersHasOneGamificationTx) Find() (result *model.UserGamification, err error) {
	return result, a.tx.Find(&result)
}

func (a usersHasOneGamificationTx) Append(values ...*model.UserGamification) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a usersHasOneGamificationTx) Replace(values ...*model.UserGamification) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a usersHasOneGamificationTx) Delete(values ...*model.UserGamification) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a usersHasOneGamificationTx) Clear() error {
	return a.tx.Clear()
}

func (a usersHasOneGamificationTx) Count() int64 {
	return a.tx.Count()
}

func (a usersHasOneGamificationTx) Unscoped() *usersHasOneGamificationTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type usersDo struct{ gen.DO }

func (u usersDo) Debug() *usersDo {
	return u.withDO(u.DO.Debug())
}

func (u usersDo) WithContext(ctx context.Context) *usersDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u usersDo) ReadDB() *usersDo {
	return u.Clauses(dbresolver.Read)
}

func (u usersDo) WriteDB() *usersDo {
	return u.Clauses(dbresolver.Write)
}

func (u usersDo) Session(config *gorm.Session) *usersDo {
	return u.withDO(u.DO.Session(config))
}

func (u usersDo) Clauses(conds ...clause.Expression) *usersDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u usersDo) Returning(value interface{}, columns ...string) *usersDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u usersDo) Not(conds ...gen.Condition) *usersDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u usersDo) Or(conds ...gen.Condition) *usersDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u usersDo) Select(conds ...field.Expr) *usersDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u usersDo) Where(conds ...gen.Condition) *usersDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u usersDo) Order(conds ...field.Expr) *usersDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u usersDo) Distinct(cols ...field.Expr) *usersDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u usersDo) Omit(cols ...field.Expr) *usersDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u usersDo) Join(table schema.Tabler, on ...field.Expr) *usersDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u usersDo) LeftJoin(table schema.Tabler, on ...field.Expr) *usersDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u usersDo) RightJoin(table schema.Tabler, on ...field.Expr) *usersDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u usersDo) Group(cols ...field.Expr) *usersDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u usersDo) Having(conds ...gen.Condition) *usersDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u usersDo) Limit(limit int) *usersDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u usersDo) Offset(offset int) *usersDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u usersDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *usersDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u usersDo) Unscoped() *usersDo {
	return u.withDO(u.DO.Unscoped())
}

func (u usersDo) Create(values ...*model.Users) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u usersDo) CreateInBatches(values []*model.Users, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u usersDo) Save(values ...*model.Users) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u usersDo) First() (*model.Users, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Users), nil
	}
}

func (u usersDo) Take() (*model.Users, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Users), nil
	}
}

func (u usersDo) Last() (*model.Users, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Users), nil
	}
}

func (u usersDo) Find() ([]*model.Users, error) {
	result, err := u.DO.Find()
	return result.([]*model.Users), err
}

func (u usersDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Users, err error) {
	buf := make([]*model.Users, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u usersDo) FindInBatches(result *[]*model.Users, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u usersDo) Attrs(attrs ...field.AssignExpr) *usersDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u usersDo) Assign(attrs ...field.AssignExpr) *usersDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u usersDo) Joins(fields ...field.RelationField) *usersDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u usersDo) Preload(fields ...field.RelationField) *usersDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u usersDo) FirstOrInit() (*model.Users, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Users), nil
	}
}

func (u usersDo) FirstOrCreate() (*model.Users, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Users), nil
	}
}

func (u usersDo) FindByPage(offset int, limit int) (result []*model.Users, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u usersDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u usersDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u usersDo) Delete(models ...*model.Users) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *usersDo) withDO(do gen.Dao) *usersDo {
	u.DO = *do.(*gen.DO)
	return u
}
