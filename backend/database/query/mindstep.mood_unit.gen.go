// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newMoodUnit(db *gorm.DB, opts ...gen.DOOption) moodUnit {
	_moodUnit := moodUnit{}

	_moodUnit.moodUnitDo.UseDB(db, opts...)
	_moodUnit.moodUnitDo.UseModel(&model.MoodUnit{})

	tableName := _moodUnit.moodUnitDo.TableName()
	_moodUnit.ALL = field.NewAsterisk(tableName)
	_moodUnit.ID = field.NewUint(tableName, "id")
	_moodUnit.CategoryID = field.NewUint(tableName, "category_id")
	_moodUnit.PlutchikID = field.NewUint(tableName, "plutchik_id")
	_moodUnit.CombinationID = field.NewUint(tableName, "combination_id")
	_moodUnit.Type = field.NewString(tableName, "type")
	_moodUnit.Description = field.NewString(tableName, "description")
	_moodUnit.DisplayNameMn = field.NewString(tableName, "display_name_mn")
	_moodUnit.DisplayNameEn = field.NewString(tableName, "display_name_en")
	_moodUnit.DisplayColor = field.NewString(tableName, "display_color")
	_moodUnit.DisplayEmoji = field.NewString(tableName, "display_emoji")
	_moodUnit.HawkinsLevelID = field.NewInt32(tableName, "hawkins_level_id")
	_moodUnit.MoodCategories = moodUnitBelongsToMoodCategories{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("MoodCategories", "model.MoodCategories"),
	}

	_moodUnit.PlutchikEmotions = moodUnitBelongsToPlutchikEmotions{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("PlutchikEmotions", "model.PlutchikEmotions"),
	}

	_moodUnit.PlutchikCombinations = moodUnitBelongsToPlutchikCombinations{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("PlutchikCombinations", "model.PlutchikCombinations"),
		Emotion1: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("PlutchikCombinations.Emotion1", "model.PlutchikEmotions"),
		},
		Emotion2: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("PlutchikCombinations.Emotion2", "model.PlutchikEmotions"),
		},
	}

	_moodUnit.fillFieldMap()

	return _moodUnit
}

type moodUnit struct {
	moodUnitDo moodUnitDo

	ALL            field.Asterisk
	ID             field.Uint
	CategoryID     field.Uint
	PlutchikID     field.Uint
	CombinationID  field.Uint
	Type           field.String
	Description    field.String
	DisplayNameMn  field.String
	DisplayNameEn  field.String
	DisplayColor   field.String
	DisplayEmoji   field.String
	HawkinsLevelID field.Int32
	MoodCategories moodUnitBelongsToMoodCategories

	PlutchikEmotions moodUnitBelongsToPlutchikEmotions

	PlutchikCombinations moodUnitBelongsToPlutchikCombinations

	fieldMap map[string]field.Expr
}

func (m moodUnit) Table(newTableName string) *moodUnit {
	m.moodUnitDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m moodUnit) As(alias string) *moodUnit {
	m.moodUnitDo.DO = *(m.moodUnitDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *moodUnit) updateTableName(table string) *moodUnit {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewUint(table, "id")
	m.CategoryID = field.NewUint(table, "category_id")
	m.PlutchikID = field.NewUint(table, "plutchik_id")
	m.CombinationID = field.NewUint(table, "combination_id")
	m.Type = field.NewString(table, "type")
	m.Description = field.NewString(table, "description")
	m.DisplayNameMn = field.NewString(table, "display_name_mn")
	m.DisplayNameEn = field.NewString(table, "display_name_en")
	m.DisplayColor = field.NewString(table, "display_color")
	m.DisplayEmoji = field.NewString(table, "display_emoji")
	m.HawkinsLevelID = field.NewInt32(table, "hawkins_level_id")

	m.fillFieldMap()

	return m
}

func (m *moodUnit) WithContext(ctx context.Context) *moodUnitDo { return m.moodUnitDo.WithContext(ctx) }

func (m moodUnit) TableName() string { return m.moodUnitDo.TableName() }

func (m moodUnit) Alias() string { return m.moodUnitDo.Alias() }

func (m moodUnit) Columns(cols ...field.Expr) gen.Columns { return m.moodUnitDo.Columns(cols...) }

func (m *moodUnit) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *moodUnit) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 14)
	m.fieldMap["id"] = m.ID
	m.fieldMap["category_id"] = m.CategoryID
	m.fieldMap["plutchik_id"] = m.PlutchikID
	m.fieldMap["combination_id"] = m.CombinationID
	m.fieldMap["type"] = m.Type
	m.fieldMap["description"] = m.Description
	m.fieldMap["display_name_mn"] = m.DisplayNameMn
	m.fieldMap["display_name_en"] = m.DisplayNameEn
	m.fieldMap["display_color"] = m.DisplayColor
	m.fieldMap["display_emoji"] = m.DisplayEmoji
	m.fieldMap["hawkins_level_id"] = m.HawkinsLevelID

}

func (m moodUnit) clone(db *gorm.DB) moodUnit {
	m.moodUnitDo.ReplaceConnPool(db.Statement.ConnPool)
	m.MoodCategories.db = db.Session(&gorm.Session{Initialized: true})
	m.MoodCategories.db.Statement.ConnPool = db.Statement.ConnPool
	m.PlutchikEmotions.db = db.Session(&gorm.Session{Initialized: true})
	m.PlutchikEmotions.db.Statement.ConnPool = db.Statement.ConnPool
	m.PlutchikCombinations.db = db.Session(&gorm.Session{Initialized: true})
	m.PlutchikCombinations.db.Statement.ConnPool = db.Statement.ConnPool
	return m
}

func (m moodUnit) replaceDB(db *gorm.DB) moodUnit {
	m.moodUnitDo.ReplaceDB(db)
	m.MoodCategories.db = db.Session(&gorm.Session{})
	m.PlutchikEmotions.db = db.Session(&gorm.Session{})
	m.PlutchikCombinations.db = db.Session(&gorm.Session{})
	return m
}

type moodUnitBelongsToMoodCategories struct {
	db *gorm.DB

	field.RelationField
}

func (a moodUnitBelongsToMoodCategories) Where(conds ...field.Expr) *moodUnitBelongsToMoodCategories {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a moodUnitBelongsToMoodCategories) WithContext(ctx context.Context) *moodUnitBelongsToMoodCategories {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a moodUnitBelongsToMoodCategories) Session(session *gorm.Session) *moodUnitBelongsToMoodCategories {
	a.db = a.db.Session(session)
	return &a
}

func (a moodUnitBelongsToMoodCategories) Model(m *model.MoodUnit) *moodUnitBelongsToMoodCategoriesTx {
	return &moodUnitBelongsToMoodCategoriesTx{a.db.Model(m).Association(a.Name())}
}

func (a moodUnitBelongsToMoodCategories) Unscoped() *moodUnitBelongsToMoodCategories {
	a.db = a.db.Unscoped()
	return &a
}

type moodUnitBelongsToMoodCategoriesTx struct{ tx *gorm.Association }

func (a moodUnitBelongsToMoodCategoriesTx) Find() (result *model.MoodCategories, err error) {
	return result, a.tx.Find(&result)
}

func (a moodUnitBelongsToMoodCategoriesTx) Append(values ...*model.MoodCategories) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a moodUnitBelongsToMoodCategoriesTx) Replace(values ...*model.MoodCategories) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a moodUnitBelongsToMoodCategoriesTx) Delete(values ...*model.MoodCategories) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a moodUnitBelongsToMoodCategoriesTx) Clear() error {
	return a.tx.Clear()
}

func (a moodUnitBelongsToMoodCategoriesTx) Count() int64 {
	return a.tx.Count()
}

func (a moodUnitBelongsToMoodCategoriesTx) Unscoped() *moodUnitBelongsToMoodCategoriesTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type moodUnitBelongsToPlutchikEmotions struct {
	db *gorm.DB

	field.RelationField
}

func (a moodUnitBelongsToPlutchikEmotions) Where(conds ...field.Expr) *moodUnitBelongsToPlutchikEmotions {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a moodUnitBelongsToPlutchikEmotions) WithContext(ctx context.Context) *moodUnitBelongsToPlutchikEmotions {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a moodUnitBelongsToPlutchikEmotions) Session(session *gorm.Session) *moodUnitBelongsToPlutchikEmotions {
	a.db = a.db.Session(session)
	return &a
}

func (a moodUnitBelongsToPlutchikEmotions) Model(m *model.MoodUnit) *moodUnitBelongsToPlutchikEmotionsTx {
	return &moodUnitBelongsToPlutchikEmotionsTx{a.db.Model(m).Association(a.Name())}
}

func (a moodUnitBelongsToPlutchikEmotions) Unscoped() *moodUnitBelongsToPlutchikEmotions {
	a.db = a.db.Unscoped()
	return &a
}

type moodUnitBelongsToPlutchikEmotionsTx struct{ tx *gorm.Association }

func (a moodUnitBelongsToPlutchikEmotionsTx) Find() (result *model.PlutchikEmotions, err error) {
	return result, a.tx.Find(&result)
}

func (a moodUnitBelongsToPlutchikEmotionsTx) Append(values ...*model.PlutchikEmotions) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a moodUnitBelongsToPlutchikEmotionsTx) Replace(values ...*model.PlutchikEmotions) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a moodUnitBelongsToPlutchikEmotionsTx) Delete(values ...*model.PlutchikEmotions) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a moodUnitBelongsToPlutchikEmotionsTx) Clear() error {
	return a.tx.Clear()
}

func (a moodUnitBelongsToPlutchikEmotionsTx) Count() int64 {
	return a.tx.Count()
}

func (a moodUnitBelongsToPlutchikEmotionsTx) Unscoped() *moodUnitBelongsToPlutchikEmotionsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type moodUnitBelongsToPlutchikCombinations struct {
	db *gorm.DB

	field.RelationField

	Emotion1 struct {
		field.RelationField
	}
	Emotion2 struct {
		field.RelationField
	}
}

func (a moodUnitBelongsToPlutchikCombinations) Where(conds ...field.Expr) *moodUnitBelongsToPlutchikCombinations {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a moodUnitBelongsToPlutchikCombinations) WithContext(ctx context.Context) *moodUnitBelongsToPlutchikCombinations {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a moodUnitBelongsToPlutchikCombinations) Session(session *gorm.Session) *moodUnitBelongsToPlutchikCombinations {
	a.db = a.db.Session(session)
	return &a
}

func (a moodUnitBelongsToPlutchikCombinations) Model(m *model.MoodUnit) *moodUnitBelongsToPlutchikCombinationsTx {
	return &moodUnitBelongsToPlutchikCombinationsTx{a.db.Model(m).Association(a.Name())}
}

func (a moodUnitBelongsToPlutchikCombinations) Unscoped() *moodUnitBelongsToPlutchikCombinations {
	a.db = a.db.Unscoped()
	return &a
}

type moodUnitBelongsToPlutchikCombinationsTx struct{ tx *gorm.Association }

func (a moodUnitBelongsToPlutchikCombinationsTx) Find() (result *model.PlutchikCombinations, err error) {
	return result, a.tx.Find(&result)
}

func (a moodUnitBelongsToPlutchikCombinationsTx) Append(values ...*model.PlutchikCombinations) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a moodUnitBelongsToPlutchikCombinationsTx) Replace(values ...*model.PlutchikCombinations) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a moodUnitBelongsToPlutchikCombinationsTx) Delete(values ...*model.PlutchikCombinations) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a moodUnitBelongsToPlutchikCombinationsTx) Clear() error {
	return a.tx.Clear()
}

func (a moodUnitBelongsToPlutchikCombinationsTx) Count() int64 {
	return a.tx.Count()
}

func (a moodUnitBelongsToPlutchikCombinationsTx) Unscoped() *moodUnitBelongsToPlutchikCombinationsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type moodUnitDo struct{ gen.DO }

func (m moodUnitDo) Debug() *moodUnitDo {
	return m.withDO(m.DO.Debug())
}

func (m moodUnitDo) WithContext(ctx context.Context) *moodUnitDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m moodUnitDo) ReadDB() *moodUnitDo {
	return m.Clauses(dbresolver.Read)
}

func (m moodUnitDo) WriteDB() *moodUnitDo {
	return m.Clauses(dbresolver.Write)
}

func (m moodUnitDo) Session(config *gorm.Session) *moodUnitDo {
	return m.withDO(m.DO.Session(config))
}

func (m moodUnitDo) Clauses(conds ...clause.Expression) *moodUnitDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m moodUnitDo) Returning(value interface{}, columns ...string) *moodUnitDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m moodUnitDo) Not(conds ...gen.Condition) *moodUnitDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m moodUnitDo) Or(conds ...gen.Condition) *moodUnitDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m moodUnitDo) Select(conds ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m moodUnitDo) Where(conds ...gen.Condition) *moodUnitDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m moodUnitDo) Order(conds ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m moodUnitDo) Distinct(cols ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m moodUnitDo) Omit(cols ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m moodUnitDo) Join(table schema.Tabler, on ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m moodUnitDo) LeftJoin(table schema.Tabler, on ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m moodUnitDo) RightJoin(table schema.Tabler, on ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m moodUnitDo) Group(cols ...field.Expr) *moodUnitDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m moodUnitDo) Having(conds ...gen.Condition) *moodUnitDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m moodUnitDo) Limit(limit int) *moodUnitDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m moodUnitDo) Offset(offset int) *moodUnitDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m moodUnitDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *moodUnitDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m moodUnitDo) Unscoped() *moodUnitDo {
	return m.withDO(m.DO.Unscoped())
}

func (m moodUnitDo) Create(values ...*model.MoodUnit) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m moodUnitDo) CreateInBatches(values []*model.MoodUnit, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m moodUnitDo) Save(values ...*model.MoodUnit) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m moodUnitDo) First() (*model.MoodUnit, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MoodUnit), nil
	}
}

func (m moodUnitDo) Take() (*model.MoodUnit, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MoodUnit), nil
	}
}

func (m moodUnitDo) Last() (*model.MoodUnit, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MoodUnit), nil
	}
}

func (m moodUnitDo) Find() ([]*model.MoodUnit, error) {
	result, err := m.DO.Find()
	return result.([]*model.MoodUnit), err
}

func (m moodUnitDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MoodUnit, err error) {
	buf := make([]*model.MoodUnit, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m moodUnitDo) FindInBatches(result *[]*model.MoodUnit, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m moodUnitDo) Attrs(attrs ...field.AssignExpr) *moodUnitDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m moodUnitDo) Assign(attrs ...field.AssignExpr) *moodUnitDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m moodUnitDo) Joins(fields ...field.RelationField) *moodUnitDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m moodUnitDo) Preload(fields ...field.RelationField) *moodUnitDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m moodUnitDo) FirstOrInit() (*model.MoodUnit, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MoodUnit), nil
	}
}

func (m moodUnitDo) FirstOrCreate() (*model.MoodUnit, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MoodUnit), nil
	}
}

func (m moodUnitDo) FindByPage(offset int, limit int) (result []*model.MoodUnit, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m moodUnitDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m moodUnitDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m moodUnitDo) Delete(models ...*model.MoodUnit) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *moodUnitDo) withDO(do gen.Dao) *moodUnitDo {
	m.DO = *do.(*gen.DO)
	return m
}
