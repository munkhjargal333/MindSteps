// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newProgressReports(db *gorm.DB, opts ...gen.DOOption) progressReports {
	_progressReports := progressReports{}

	_progressReports.progressReportsDo.UseDB(db, opts...)
	_progressReports.progressReportsDo.UseModel(&model.ProgressReports{})

	tableName := _progressReports.progressReportsDo.TableName()
	_progressReports.ALL = field.NewAsterisk(tableName)
	_progressReports.ID = field.NewUint(tableName, "id")
	_progressReports.UserID = field.NewUint(tableName, "user_id")
	_progressReports.ReportType = field.NewString(tableName, "report_type")
	_progressReports.PeriodStart = field.NewTime(tableName, "period_start")
	_progressReports.PeriodEnd = field.NewTime(tableName, "period_end")
	_progressReports.OverallWellbeingScore = field.NewInt(tableName, "overall_wellbeing_score")
	_progressReports.MoodSummary = field.NewString(tableName, "mood_summary")
	_progressReports.JournalInsights = field.NewString(tableName, "journal_insights")
	_progressReports.GoalProgress = field.NewString(tableName, "goal_progress")
	_progressReports.MeditationSummary = field.NewString(tableName, "meditation_summary")
	_progressReports.KeyAchievements = field.NewString(tableName, "key_achievements")
	_progressReports.AreasForImprovement = field.NewString(tableName, "areas_for_improvement")
	_progressReports.PersonalizedRecommendations = field.NewString(tableName, "personalized_recommendations")
	_progressReports.GeneratedAt = field.NewTime(tableName, "generated_at")
	_progressReports.User = progressReportsBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.Users"),
	}

	_progressReports.fillFieldMap()

	return _progressReports
}

type progressReports struct {
	progressReportsDo progressReportsDo

	ALL                         field.Asterisk
	ID                          field.Uint
	UserID                      field.Uint
	ReportType                  field.String
	PeriodStart                 field.Time
	PeriodEnd                   field.Time
	OverallWellbeingScore       field.Int
	MoodSummary                 field.String
	JournalInsights             field.String
	GoalProgress                field.String
	MeditationSummary           field.String
	KeyAchievements             field.String
	AreasForImprovement         field.String
	PersonalizedRecommendations field.String
	GeneratedAt                 field.Time
	User                        progressReportsBelongsToUser

	fieldMap map[string]field.Expr
}

func (p progressReports) Table(newTableName string) *progressReports {
	p.progressReportsDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p progressReports) As(alias string) *progressReports {
	p.progressReportsDo.DO = *(p.progressReportsDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *progressReports) updateTableName(table string) *progressReports {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewUint(table, "id")
	p.UserID = field.NewUint(table, "user_id")
	p.ReportType = field.NewString(table, "report_type")
	p.PeriodStart = field.NewTime(table, "period_start")
	p.PeriodEnd = field.NewTime(table, "period_end")
	p.OverallWellbeingScore = field.NewInt(table, "overall_wellbeing_score")
	p.MoodSummary = field.NewString(table, "mood_summary")
	p.JournalInsights = field.NewString(table, "journal_insights")
	p.GoalProgress = field.NewString(table, "goal_progress")
	p.MeditationSummary = field.NewString(table, "meditation_summary")
	p.KeyAchievements = field.NewString(table, "key_achievements")
	p.AreasForImprovement = field.NewString(table, "areas_for_improvement")
	p.PersonalizedRecommendations = field.NewString(table, "personalized_recommendations")
	p.GeneratedAt = field.NewTime(table, "generated_at")

	p.fillFieldMap()

	return p
}

func (p *progressReports) WithContext(ctx context.Context) *progressReportsDo {
	return p.progressReportsDo.WithContext(ctx)
}

func (p progressReports) TableName() string { return p.progressReportsDo.TableName() }

func (p progressReports) Alias() string { return p.progressReportsDo.Alias() }

func (p progressReports) Columns(cols ...field.Expr) gen.Columns {
	return p.progressReportsDo.Columns(cols...)
}

func (p *progressReports) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *progressReports) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 15)
	p.fieldMap["id"] = p.ID
	p.fieldMap["user_id"] = p.UserID
	p.fieldMap["report_type"] = p.ReportType
	p.fieldMap["period_start"] = p.PeriodStart
	p.fieldMap["period_end"] = p.PeriodEnd
	p.fieldMap["overall_wellbeing_score"] = p.OverallWellbeingScore
	p.fieldMap["mood_summary"] = p.MoodSummary
	p.fieldMap["journal_insights"] = p.JournalInsights
	p.fieldMap["goal_progress"] = p.GoalProgress
	p.fieldMap["meditation_summary"] = p.MeditationSummary
	p.fieldMap["key_achievements"] = p.KeyAchievements
	p.fieldMap["areas_for_improvement"] = p.AreasForImprovement
	p.fieldMap["personalized_recommendations"] = p.PersonalizedRecommendations
	p.fieldMap["generated_at"] = p.GeneratedAt

}

func (p progressReports) clone(db *gorm.DB) progressReports {
	p.progressReportsDo.ReplaceConnPool(db.Statement.ConnPool)
	p.User.db = db.Session(&gorm.Session{Initialized: true})
	p.User.db.Statement.ConnPool = db.Statement.ConnPool
	return p
}

func (p progressReports) replaceDB(db *gorm.DB) progressReports {
	p.progressReportsDo.ReplaceDB(db)
	p.User.db = db.Session(&gorm.Session{})
	return p
}

type progressReportsBelongsToUser struct {
	db *gorm.DB

	field.RelationField
}

func (a progressReportsBelongsToUser) Where(conds ...field.Expr) *progressReportsBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a progressReportsBelongsToUser) WithContext(ctx context.Context) *progressReportsBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a progressReportsBelongsToUser) Session(session *gorm.Session) *progressReportsBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a progressReportsBelongsToUser) Model(m *model.ProgressReports) *progressReportsBelongsToUserTx {
	return &progressReportsBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

func (a progressReportsBelongsToUser) Unscoped() *progressReportsBelongsToUser {
	a.db = a.db.Unscoped()
	return &a
}

type progressReportsBelongsToUserTx struct{ tx *gorm.Association }

func (a progressReportsBelongsToUserTx) Find() (result *model.Users, err error) {
	return result, a.tx.Find(&result)
}

func (a progressReportsBelongsToUserTx) Append(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a progressReportsBelongsToUserTx) Replace(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a progressReportsBelongsToUserTx) Delete(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a progressReportsBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a progressReportsBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

func (a progressReportsBelongsToUserTx) Unscoped() *progressReportsBelongsToUserTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type progressReportsDo struct{ gen.DO }

func (p progressReportsDo) Debug() *progressReportsDo {
	return p.withDO(p.DO.Debug())
}

func (p progressReportsDo) WithContext(ctx context.Context) *progressReportsDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p progressReportsDo) ReadDB() *progressReportsDo {
	return p.Clauses(dbresolver.Read)
}

func (p progressReportsDo) WriteDB() *progressReportsDo {
	return p.Clauses(dbresolver.Write)
}

func (p progressReportsDo) Session(config *gorm.Session) *progressReportsDo {
	return p.withDO(p.DO.Session(config))
}

func (p progressReportsDo) Clauses(conds ...clause.Expression) *progressReportsDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p progressReportsDo) Returning(value interface{}, columns ...string) *progressReportsDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p progressReportsDo) Not(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p progressReportsDo) Or(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p progressReportsDo) Select(conds ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p progressReportsDo) Where(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p progressReportsDo) Order(conds ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p progressReportsDo) Distinct(cols ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p progressReportsDo) Omit(cols ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p progressReportsDo) Join(table schema.Tabler, on ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p progressReportsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p progressReportsDo) RightJoin(table schema.Tabler, on ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p progressReportsDo) Group(cols ...field.Expr) *progressReportsDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p progressReportsDo) Having(conds ...gen.Condition) *progressReportsDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p progressReportsDo) Limit(limit int) *progressReportsDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p progressReportsDo) Offset(offset int) *progressReportsDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p progressReportsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *progressReportsDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p progressReportsDo) Unscoped() *progressReportsDo {
	return p.withDO(p.DO.Unscoped())
}

func (p progressReportsDo) Create(values ...*model.ProgressReports) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p progressReportsDo) CreateInBatches(values []*model.ProgressReports, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p progressReportsDo) Save(values ...*model.ProgressReports) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p progressReportsDo) First() (*model.ProgressReports, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) Take() (*model.ProgressReports, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) Last() (*model.ProgressReports, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) Find() ([]*model.ProgressReports, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProgressReports), err
}

func (p progressReportsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProgressReports, err error) {
	buf := make([]*model.ProgressReports, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p progressReportsDo) FindInBatches(result *[]*model.ProgressReports, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p progressReportsDo) Attrs(attrs ...field.AssignExpr) *progressReportsDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p progressReportsDo) Assign(attrs ...field.AssignExpr) *progressReportsDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p progressReportsDo) Joins(fields ...field.RelationField) *progressReportsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p progressReportsDo) Preload(fields ...field.RelationField) *progressReportsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p progressReportsDo) FirstOrInit() (*model.ProgressReports, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) FirstOrCreate() (*model.ProgressReports, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProgressReports), nil
	}
}

func (p progressReportsDo) FindByPage(offset int, limit int) (result []*model.ProgressReports, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p progressReportsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p progressReportsDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p progressReportsDo) Delete(models ...*model.ProgressReports) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *progressReportsDo) withDO(do gen.Dao) *progressReportsDo {
	p.DO = *do.(*gen.DO)
	return p
}
