// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newDetectedPatterns(db *gorm.DB, opts ...gen.DOOption) detectedPatterns {
	_detectedPatterns := detectedPatterns{}

	_detectedPatterns.detectedPatternsDo.UseDB(db, opts...)
	_detectedPatterns.detectedPatternsDo.UseModel(&model.DetectedPatterns{})

	tableName := _detectedPatterns.detectedPatternsDo.TableName()
	_detectedPatterns.ALL = field.NewAsterisk(tableName)
	_detectedPatterns.ID = field.NewUint(tableName, "id")
	_detectedPatterns.UserID = field.NewUint(tableName, "user_id")
	_detectedPatterns.PatternType = field.NewString(tableName, "pattern_type")
	_detectedPatterns.PatternCategory = field.NewString(tableName, "pattern_category")
	_detectedPatterns.PatternName = field.NewString(tableName, "pattern_name")
	_detectedPatterns.Description = field.NewString(tableName, "description")
	_detectedPatterns.DetectedFrom = field.NewString(tableName, "detected_from")
	_detectedPatterns.Frequency = field.NewString(tableName, "frequency")
	_detectedPatterns.ConfidenceScore = field.NewFloat64(tableName, "confidence_score")
	_detectedPatterns.FirstDetected = field.NewTime(tableName, "first_detected")
	_detectedPatterns.LastDetected = field.NewTime(tableName, "last_detected")
	_detectedPatterns.OccurrenceCount = field.NewInt(tableName, "occurrence_count")
	_detectedPatterns.Severity = field.NewString(tableName, "severity")
	_detectedPatterns.RelatedValueIds = field.NewString(tableName, "related_value_ids")
	_detectedPatterns.EmotionalImpactScore = field.NewInt(tableName, "emotional_impact_score")
	_detectedPatterns.SuggestedActions = field.NewString(tableName, "suggested_actions")
	_detectedPatterns.RecommendedLessonIds = field.NewString(tableName, "recommended_lesson_ids")
	_detectedPatterns.IsResolved = field.NewBool(tableName, "is_resolved")
	_detectedPatterns.ResolvedAt = field.NewTime(tableName, "resolved_at")
	_detectedPatterns.UserAcknowledged = field.NewBool(tableName, "user_acknowledged")
	_detectedPatterns.AcknowledgedAt = field.NewTime(tableName, "acknowledged_at")
	_detectedPatterns.CreatedAt = field.NewTime(tableName, "created_at")
	_detectedPatterns.UpdatedAt = field.NewTime(tableName, "updated_at")

	_detectedPatterns.fillFieldMap()

	return _detectedPatterns
}

type detectedPatterns struct {
	detectedPatternsDo detectedPatternsDo

	ALL                  field.Asterisk
	ID                   field.Uint
	UserID               field.Uint
	PatternType          field.String
	PatternCategory      field.String
	PatternName          field.String
	Description          field.String
	DetectedFrom         field.String
	Frequency            field.String
	ConfidenceScore      field.Float64
	FirstDetected        field.Time
	LastDetected         field.Time
	OccurrenceCount      field.Int
	Severity             field.String
	RelatedValueIds      field.String
	EmotionalImpactScore field.Int
	SuggestedActions     field.String
	RecommendedLessonIds field.String
	IsResolved           field.Bool
	ResolvedAt           field.Time
	UserAcknowledged     field.Bool
	AcknowledgedAt       field.Time
	CreatedAt            field.Time
	UpdatedAt            field.Time

	fieldMap map[string]field.Expr
}

func (d detectedPatterns) Table(newTableName string) *detectedPatterns {
	d.detectedPatternsDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d detectedPatterns) As(alias string) *detectedPatterns {
	d.detectedPatternsDo.DO = *(d.detectedPatternsDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *detectedPatterns) updateTableName(table string) *detectedPatterns {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewUint(table, "id")
	d.UserID = field.NewUint(table, "user_id")
	d.PatternType = field.NewString(table, "pattern_type")
	d.PatternCategory = field.NewString(table, "pattern_category")
	d.PatternName = field.NewString(table, "pattern_name")
	d.Description = field.NewString(table, "description")
	d.DetectedFrom = field.NewString(table, "detected_from")
	d.Frequency = field.NewString(table, "frequency")
	d.ConfidenceScore = field.NewFloat64(table, "confidence_score")
	d.FirstDetected = field.NewTime(table, "first_detected")
	d.LastDetected = field.NewTime(table, "last_detected")
	d.OccurrenceCount = field.NewInt(table, "occurrence_count")
	d.Severity = field.NewString(table, "severity")
	d.RelatedValueIds = field.NewString(table, "related_value_ids")
	d.EmotionalImpactScore = field.NewInt(table, "emotional_impact_score")
	d.SuggestedActions = field.NewString(table, "suggested_actions")
	d.RecommendedLessonIds = field.NewString(table, "recommended_lesson_ids")
	d.IsResolved = field.NewBool(table, "is_resolved")
	d.ResolvedAt = field.NewTime(table, "resolved_at")
	d.UserAcknowledged = field.NewBool(table, "user_acknowledged")
	d.AcknowledgedAt = field.NewTime(table, "acknowledged_at")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")

	d.fillFieldMap()

	return d
}

func (d *detectedPatterns) WithContext(ctx context.Context) *detectedPatternsDo {
	return d.detectedPatternsDo.WithContext(ctx)
}

func (d detectedPatterns) TableName() string { return d.detectedPatternsDo.TableName() }

func (d detectedPatterns) Alias() string { return d.detectedPatternsDo.Alias() }

func (d detectedPatterns) Columns(cols ...field.Expr) gen.Columns {
	return d.detectedPatternsDo.Columns(cols...)
}

func (d *detectedPatterns) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *detectedPatterns) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 23)
	d.fieldMap["id"] = d.ID
	d.fieldMap["user_id"] = d.UserID
	d.fieldMap["pattern_type"] = d.PatternType
	d.fieldMap["pattern_category"] = d.PatternCategory
	d.fieldMap["pattern_name"] = d.PatternName
	d.fieldMap["description"] = d.Description
	d.fieldMap["detected_from"] = d.DetectedFrom
	d.fieldMap["frequency"] = d.Frequency
	d.fieldMap["confidence_score"] = d.ConfidenceScore
	d.fieldMap["first_detected"] = d.FirstDetected
	d.fieldMap["last_detected"] = d.LastDetected
	d.fieldMap["occurrence_count"] = d.OccurrenceCount
	d.fieldMap["severity"] = d.Severity
	d.fieldMap["related_value_ids"] = d.RelatedValueIds
	d.fieldMap["emotional_impact_score"] = d.EmotionalImpactScore
	d.fieldMap["suggested_actions"] = d.SuggestedActions
	d.fieldMap["recommended_lesson_ids"] = d.RecommendedLessonIds
	d.fieldMap["is_resolved"] = d.IsResolved
	d.fieldMap["resolved_at"] = d.ResolvedAt
	d.fieldMap["user_acknowledged"] = d.UserAcknowledged
	d.fieldMap["acknowledged_at"] = d.AcknowledgedAt
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
}

func (d detectedPatterns) clone(db *gorm.DB) detectedPatterns {
	d.detectedPatternsDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d detectedPatterns) replaceDB(db *gorm.DB) detectedPatterns {
	d.detectedPatternsDo.ReplaceDB(db)
	return d
}

type detectedPatternsDo struct{ gen.DO }

func (d detectedPatternsDo) Debug() *detectedPatternsDo {
	return d.withDO(d.DO.Debug())
}

func (d detectedPatternsDo) WithContext(ctx context.Context) *detectedPatternsDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d detectedPatternsDo) ReadDB() *detectedPatternsDo {
	return d.Clauses(dbresolver.Read)
}

func (d detectedPatternsDo) WriteDB() *detectedPatternsDo {
	return d.Clauses(dbresolver.Write)
}

func (d detectedPatternsDo) Session(config *gorm.Session) *detectedPatternsDo {
	return d.withDO(d.DO.Session(config))
}

func (d detectedPatternsDo) Clauses(conds ...clause.Expression) *detectedPatternsDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d detectedPatternsDo) Returning(value interface{}, columns ...string) *detectedPatternsDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d detectedPatternsDo) Not(conds ...gen.Condition) *detectedPatternsDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d detectedPatternsDo) Or(conds ...gen.Condition) *detectedPatternsDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d detectedPatternsDo) Select(conds ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d detectedPatternsDo) Where(conds ...gen.Condition) *detectedPatternsDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d detectedPatternsDo) Order(conds ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d detectedPatternsDo) Distinct(cols ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d detectedPatternsDo) Omit(cols ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d detectedPatternsDo) Join(table schema.Tabler, on ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d detectedPatternsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d detectedPatternsDo) RightJoin(table schema.Tabler, on ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d detectedPatternsDo) Group(cols ...field.Expr) *detectedPatternsDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d detectedPatternsDo) Having(conds ...gen.Condition) *detectedPatternsDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d detectedPatternsDo) Limit(limit int) *detectedPatternsDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d detectedPatternsDo) Offset(offset int) *detectedPatternsDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d detectedPatternsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *detectedPatternsDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d detectedPatternsDo) Unscoped() *detectedPatternsDo {
	return d.withDO(d.DO.Unscoped())
}

func (d detectedPatternsDo) Create(values ...*model.DetectedPatterns) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d detectedPatternsDo) CreateInBatches(values []*model.DetectedPatterns, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d detectedPatternsDo) Save(values ...*model.DetectedPatterns) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d detectedPatternsDo) First() (*model.DetectedPatterns, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectedPatterns), nil
	}
}

func (d detectedPatternsDo) Take() (*model.DetectedPatterns, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectedPatterns), nil
	}
}

func (d detectedPatternsDo) Last() (*model.DetectedPatterns, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectedPatterns), nil
	}
}

func (d detectedPatternsDo) Find() ([]*model.DetectedPatterns, error) {
	result, err := d.DO.Find()
	return result.([]*model.DetectedPatterns), err
}

func (d detectedPatternsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DetectedPatterns, err error) {
	buf := make([]*model.DetectedPatterns, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d detectedPatternsDo) FindInBatches(result *[]*model.DetectedPatterns, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d detectedPatternsDo) Attrs(attrs ...field.AssignExpr) *detectedPatternsDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d detectedPatternsDo) Assign(attrs ...field.AssignExpr) *detectedPatternsDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d detectedPatternsDo) Joins(fields ...field.RelationField) *detectedPatternsDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d detectedPatternsDo) Preload(fields ...field.RelationField) *detectedPatternsDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d detectedPatternsDo) FirstOrInit() (*model.DetectedPatterns, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectedPatterns), nil
	}
}

func (d detectedPatternsDo) FirstOrCreate() (*model.DetectedPatterns, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DetectedPatterns), nil
	}
}

func (d detectedPatternsDo) FindByPage(offset int, limit int) (result []*model.DetectedPatterns, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d detectedPatternsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d detectedPatternsDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d detectedPatternsDo) Delete(models ...*model.DetectedPatterns) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *detectedPatternsDo) withDO(do gen.Dao) *detectedPatternsDo {
	d.DO = *do.(*gen.DO)
	return d
}
