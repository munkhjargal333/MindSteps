// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"mindsteps/database/model"
)

func newLessonRecommendations(db *gorm.DB, opts ...gen.DOOption) lessonRecommendations {
	_lessonRecommendations := lessonRecommendations{}

	_lessonRecommendations.lessonRecommendationsDo.UseDB(db, opts...)
	_lessonRecommendations.lessonRecommendationsDo.UseModel(&model.LessonRecommendations{})

	tableName := _lessonRecommendations.lessonRecommendationsDo.TableName()
	_lessonRecommendations.ALL = field.NewAsterisk(tableName)
	_lessonRecommendations.ID = field.NewUint(tableName, "id")
	_lessonRecommendations.UserID = field.NewUint(tableName, "user_id")
	_lessonRecommendations.LessonID = field.NewUint(tableName, "lesson_id")
	_lessonRecommendations.RecommendationReason = field.NewString(tableName, "recommendation_reason")
	_lessonRecommendations.RelatedValueID = field.NewUint(tableName, "related_value_id")
	_lessonRecommendations.RelatedPatternID = field.NewUint(tableName, "related_pattern_id")
	_lessonRecommendations.PriorityScore = field.NewInt(tableName, "priority_score")
	_lessonRecommendations.IsDismissed = field.NewBool(tableName, "is_dismissed")
	_lessonRecommendations.DismissedAt = field.NewTime(tableName, "dismissed_at")
	_lessonRecommendations.ViewedAt = field.NewTime(tableName, "viewed_at")
	_lessonRecommendations.CreatedAt = field.NewTime(tableName, "created_at")
	_lessonRecommendations.User = lessonRecommendationsBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.Users"),
		Gamification: struct {
			field.RelationField
			Level struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("User.Gamification", "model.UserGamification"),
			Level: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("User.Gamification.Level", "model.UserLevels"),
			},
		},
	}

	_lessonRecommendations.Lesson = lessonRecommendationsBelongsToLesson{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Lesson", "model.Lessons"),
		Category: struct {
			field.RelationField
			Children struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Lesson.Category", "model.LessonCategory"),
			Children: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Lesson.Category.Children", "model.LessonCategory"),
			},
		},
	}

	_lessonRecommendations.RelatedValue = lessonRecommendationsBelongsToRelatedValue{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("RelatedValue", "model.CoreValues"),
		User: struct {
			field.RelationField
			Gamification struct {
				field.RelationField
				Level struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("RelatedValue.User", "model.Users"),
			Gamification: struct {
				field.RelationField
				Level struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("RelatedValue.User.Gamification", "model.UserGamification"),
				Level: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("RelatedValue.User.Gamification.Level", "model.UserLevels"),
				},
			},
		},
		MaslowLevel: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("RelatedValue.MaslowLevel", "model.MaslowLevels"),
		},
	}

	_lessonRecommendations.fillFieldMap()

	return _lessonRecommendations
}

type lessonRecommendations struct {
	lessonRecommendationsDo lessonRecommendationsDo

	ALL                  field.Asterisk
	ID                   field.Uint
	UserID               field.Uint
	LessonID             field.Uint
	RecommendationReason field.String
	RelatedValueID       field.Uint
	RelatedPatternID     field.Uint
	PriorityScore        field.Int
	IsDismissed          field.Bool
	DismissedAt          field.Time
	ViewedAt             field.Time
	CreatedAt            field.Time
	User                 lessonRecommendationsBelongsToUser

	Lesson lessonRecommendationsBelongsToLesson

	RelatedValue lessonRecommendationsBelongsToRelatedValue

	fieldMap map[string]field.Expr
}

func (l lessonRecommendations) Table(newTableName string) *lessonRecommendations {
	l.lessonRecommendationsDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l lessonRecommendations) As(alias string) *lessonRecommendations {
	l.lessonRecommendationsDo.DO = *(l.lessonRecommendationsDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *lessonRecommendations) updateTableName(table string) *lessonRecommendations {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewUint(table, "id")
	l.UserID = field.NewUint(table, "user_id")
	l.LessonID = field.NewUint(table, "lesson_id")
	l.RecommendationReason = field.NewString(table, "recommendation_reason")
	l.RelatedValueID = field.NewUint(table, "related_value_id")
	l.RelatedPatternID = field.NewUint(table, "related_pattern_id")
	l.PriorityScore = field.NewInt(table, "priority_score")
	l.IsDismissed = field.NewBool(table, "is_dismissed")
	l.DismissedAt = field.NewTime(table, "dismissed_at")
	l.ViewedAt = field.NewTime(table, "viewed_at")
	l.CreatedAt = field.NewTime(table, "created_at")

	l.fillFieldMap()

	return l
}

func (l *lessonRecommendations) WithContext(ctx context.Context) *lessonRecommendationsDo {
	return l.lessonRecommendationsDo.WithContext(ctx)
}

func (l lessonRecommendations) TableName() string { return l.lessonRecommendationsDo.TableName() }

func (l lessonRecommendations) Alias() string { return l.lessonRecommendationsDo.Alias() }

func (l lessonRecommendations) Columns(cols ...field.Expr) gen.Columns {
	return l.lessonRecommendationsDo.Columns(cols...)
}

func (l *lessonRecommendations) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *lessonRecommendations) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 14)
	l.fieldMap["id"] = l.ID
	l.fieldMap["user_id"] = l.UserID
	l.fieldMap["lesson_id"] = l.LessonID
	l.fieldMap["recommendation_reason"] = l.RecommendationReason
	l.fieldMap["related_value_id"] = l.RelatedValueID
	l.fieldMap["related_pattern_id"] = l.RelatedPatternID
	l.fieldMap["priority_score"] = l.PriorityScore
	l.fieldMap["is_dismissed"] = l.IsDismissed
	l.fieldMap["dismissed_at"] = l.DismissedAt
	l.fieldMap["viewed_at"] = l.ViewedAt
	l.fieldMap["created_at"] = l.CreatedAt

}

func (l lessonRecommendations) clone(db *gorm.DB) lessonRecommendations {
	l.lessonRecommendationsDo.ReplaceConnPool(db.Statement.ConnPool)
	l.User.db = db.Session(&gorm.Session{Initialized: true})
	l.User.db.Statement.ConnPool = db.Statement.ConnPool
	l.Lesson.db = db.Session(&gorm.Session{Initialized: true})
	l.Lesson.db.Statement.ConnPool = db.Statement.ConnPool
	l.RelatedValue.db = db.Session(&gorm.Session{Initialized: true})
	l.RelatedValue.db.Statement.ConnPool = db.Statement.ConnPool
	return l
}

func (l lessonRecommendations) replaceDB(db *gorm.DB) lessonRecommendations {
	l.lessonRecommendationsDo.ReplaceDB(db)
	l.User.db = db.Session(&gorm.Session{})
	l.Lesson.db = db.Session(&gorm.Session{})
	l.RelatedValue.db = db.Session(&gorm.Session{})
	return l
}

type lessonRecommendationsBelongsToUser struct {
	db *gorm.DB

	field.RelationField

	Gamification struct {
		field.RelationField
		Level struct {
			field.RelationField
		}
	}
}

func (a lessonRecommendationsBelongsToUser) Where(conds ...field.Expr) *lessonRecommendationsBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a lessonRecommendationsBelongsToUser) WithContext(ctx context.Context) *lessonRecommendationsBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a lessonRecommendationsBelongsToUser) Session(session *gorm.Session) *lessonRecommendationsBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a lessonRecommendationsBelongsToUser) Model(m *model.LessonRecommendations) *lessonRecommendationsBelongsToUserTx {
	return &lessonRecommendationsBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

func (a lessonRecommendationsBelongsToUser) Unscoped() *lessonRecommendationsBelongsToUser {
	a.db = a.db.Unscoped()
	return &a
}

type lessonRecommendationsBelongsToUserTx struct{ tx *gorm.Association }

func (a lessonRecommendationsBelongsToUserTx) Find() (result *model.Users, err error) {
	return result, a.tx.Find(&result)
}

func (a lessonRecommendationsBelongsToUserTx) Append(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a lessonRecommendationsBelongsToUserTx) Replace(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a lessonRecommendationsBelongsToUserTx) Delete(values ...*model.Users) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a lessonRecommendationsBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a lessonRecommendationsBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

func (a lessonRecommendationsBelongsToUserTx) Unscoped() *lessonRecommendationsBelongsToUserTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type lessonRecommendationsBelongsToLesson struct {
	db *gorm.DB

	field.RelationField

	Category struct {
		field.RelationField
		Children struct {
			field.RelationField
		}
	}
}

func (a lessonRecommendationsBelongsToLesson) Where(conds ...field.Expr) *lessonRecommendationsBelongsToLesson {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a lessonRecommendationsBelongsToLesson) WithContext(ctx context.Context) *lessonRecommendationsBelongsToLesson {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a lessonRecommendationsBelongsToLesson) Session(session *gorm.Session) *lessonRecommendationsBelongsToLesson {
	a.db = a.db.Session(session)
	return &a
}

func (a lessonRecommendationsBelongsToLesson) Model(m *model.LessonRecommendations) *lessonRecommendationsBelongsToLessonTx {
	return &lessonRecommendationsBelongsToLessonTx{a.db.Model(m).Association(a.Name())}
}

func (a lessonRecommendationsBelongsToLesson) Unscoped() *lessonRecommendationsBelongsToLesson {
	a.db = a.db.Unscoped()
	return &a
}

type lessonRecommendationsBelongsToLessonTx struct{ tx *gorm.Association }

func (a lessonRecommendationsBelongsToLessonTx) Find() (result *model.Lessons, err error) {
	return result, a.tx.Find(&result)
}

func (a lessonRecommendationsBelongsToLessonTx) Append(values ...*model.Lessons) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a lessonRecommendationsBelongsToLessonTx) Replace(values ...*model.Lessons) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a lessonRecommendationsBelongsToLessonTx) Delete(values ...*model.Lessons) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a lessonRecommendationsBelongsToLessonTx) Clear() error {
	return a.tx.Clear()
}

func (a lessonRecommendationsBelongsToLessonTx) Count() int64 {
	return a.tx.Count()
}

func (a lessonRecommendationsBelongsToLessonTx) Unscoped() *lessonRecommendationsBelongsToLessonTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type lessonRecommendationsBelongsToRelatedValue struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		Gamification struct {
			field.RelationField
			Level struct {
				field.RelationField
			}
		}
	}
	MaslowLevel struct {
		field.RelationField
	}
}

func (a lessonRecommendationsBelongsToRelatedValue) Where(conds ...field.Expr) *lessonRecommendationsBelongsToRelatedValue {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a lessonRecommendationsBelongsToRelatedValue) WithContext(ctx context.Context) *lessonRecommendationsBelongsToRelatedValue {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a lessonRecommendationsBelongsToRelatedValue) Session(session *gorm.Session) *lessonRecommendationsBelongsToRelatedValue {
	a.db = a.db.Session(session)
	return &a
}

func (a lessonRecommendationsBelongsToRelatedValue) Model(m *model.LessonRecommendations) *lessonRecommendationsBelongsToRelatedValueTx {
	return &lessonRecommendationsBelongsToRelatedValueTx{a.db.Model(m).Association(a.Name())}
}

func (a lessonRecommendationsBelongsToRelatedValue) Unscoped() *lessonRecommendationsBelongsToRelatedValue {
	a.db = a.db.Unscoped()
	return &a
}

type lessonRecommendationsBelongsToRelatedValueTx struct{ tx *gorm.Association }

func (a lessonRecommendationsBelongsToRelatedValueTx) Find() (result *model.CoreValues, err error) {
	return result, a.tx.Find(&result)
}

func (a lessonRecommendationsBelongsToRelatedValueTx) Append(values ...*model.CoreValues) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a lessonRecommendationsBelongsToRelatedValueTx) Replace(values ...*model.CoreValues) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a lessonRecommendationsBelongsToRelatedValueTx) Delete(values ...*model.CoreValues) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a lessonRecommendationsBelongsToRelatedValueTx) Clear() error {
	return a.tx.Clear()
}

func (a lessonRecommendationsBelongsToRelatedValueTx) Count() int64 {
	return a.tx.Count()
}

func (a lessonRecommendationsBelongsToRelatedValueTx) Unscoped() *lessonRecommendationsBelongsToRelatedValueTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type lessonRecommendationsDo struct{ gen.DO }

func (l lessonRecommendationsDo) Debug() *lessonRecommendationsDo {
	return l.withDO(l.DO.Debug())
}

func (l lessonRecommendationsDo) WithContext(ctx context.Context) *lessonRecommendationsDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l lessonRecommendationsDo) ReadDB() *lessonRecommendationsDo {
	return l.Clauses(dbresolver.Read)
}

func (l lessonRecommendationsDo) WriteDB() *lessonRecommendationsDo {
	return l.Clauses(dbresolver.Write)
}

func (l lessonRecommendationsDo) Session(config *gorm.Session) *lessonRecommendationsDo {
	return l.withDO(l.DO.Session(config))
}

func (l lessonRecommendationsDo) Clauses(conds ...clause.Expression) *lessonRecommendationsDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l lessonRecommendationsDo) Returning(value interface{}, columns ...string) *lessonRecommendationsDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l lessonRecommendationsDo) Not(conds ...gen.Condition) *lessonRecommendationsDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l lessonRecommendationsDo) Or(conds ...gen.Condition) *lessonRecommendationsDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l lessonRecommendationsDo) Select(conds ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l lessonRecommendationsDo) Where(conds ...gen.Condition) *lessonRecommendationsDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l lessonRecommendationsDo) Order(conds ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l lessonRecommendationsDo) Distinct(cols ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l lessonRecommendationsDo) Omit(cols ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l lessonRecommendationsDo) Join(table schema.Tabler, on ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l lessonRecommendationsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l lessonRecommendationsDo) RightJoin(table schema.Tabler, on ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l lessonRecommendationsDo) Group(cols ...field.Expr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l lessonRecommendationsDo) Having(conds ...gen.Condition) *lessonRecommendationsDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l lessonRecommendationsDo) Limit(limit int) *lessonRecommendationsDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l lessonRecommendationsDo) Offset(offset int) *lessonRecommendationsDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l lessonRecommendationsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *lessonRecommendationsDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l lessonRecommendationsDo) Unscoped() *lessonRecommendationsDo {
	return l.withDO(l.DO.Unscoped())
}

func (l lessonRecommendationsDo) Create(values ...*model.LessonRecommendations) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l lessonRecommendationsDo) CreateInBatches(values []*model.LessonRecommendations, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l lessonRecommendationsDo) Save(values ...*model.LessonRecommendations) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l lessonRecommendationsDo) First() (*model.LessonRecommendations, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LessonRecommendations), nil
	}
}

func (l lessonRecommendationsDo) Take() (*model.LessonRecommendations, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LessonRecommendations), nil
	}
}

func (l lessonRecommendationsDo) Last() (*model.LessonRecommendations, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LessonRecommendations), nil
	}
}

func (l lessonRecommendationsDo) Find() ([]*model.LessonRecommendations, error) {
	result, err := l.DO.Find()
	return result.([]*model.LessonRecommendations), err
}

func (l lessonRecommendationsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LessonRecommendations, err error) {
	buf := make([]*model.LessonRecommendations, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l lessonRecommendationsDo) FindInBatches(result *[]*model.LessonRecommendations, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l lessonRecommendationsDo) Attrs(attrs ...field.AssignExpr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l lessonRecommendationsDo) Assign(attrs ...field.AssignExpr) *lessonRecommendationsDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l lessonRecommendationsDo) Joins(fields ...field.RelationField) *lessonRecommendationsDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l lessonRecommendationsDo) Preload(fields ...field.RelationField) *lessonRecommendationsDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l lessonRecommendationsDo) FirstOrInit() (*model.LessonRecommendations, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LessonRecommendations), nil
	}
}

func (l lessonRecommendationsDo) FirstOrCreate() (*model.LessonRecommendations, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LessonRecommendations), nil
	}
}

func (l lessonRecommendationsDo) FindByPage(offset int, limit int) (result []*model.LessonRecommendations, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l lessonRecommendationsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l lessonRecommendationsDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l lessonRecommendationsDo) Delete(models ...*model.LessonRecommendations) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *lessonRecommendationsDo) withDO(do gen.Dao) *lessonRecommendationsDo {
	l.DO = *do.(*gen.DO)
	return l
}
